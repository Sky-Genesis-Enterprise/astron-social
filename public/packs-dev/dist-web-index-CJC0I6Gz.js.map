{"version":3,"file":"dist-web-index-CJC0I6Gz.js","sources":["../../node_modules/arrow-key-navigation/dist-web/index.js"],"sourcesContent":["/**\n * Makes it so the left and right arrows change focus, ala Tab/Shift+Tab. This is mostly designed\n * for KaiOS devices.\n */\n/* global document, addEventListener, removeEventListener, getSelection */\n// TODO: email/number types are a special type, in that they return selectionStart/selectionEnd as null\n// As far as I can tell, there is no way to actually get the caret position from these inputs. So we\n// don't do the proper caret handling for those inputs, unfortunately.\n// https://html.spec.whatwg.org/multipage/input.html#do-not-apply\nvar textInputTypes = ['text', 'search', 'url', 'password', 'tel'];\nvar checkboxRadioInputTypes = ['checkbox', 'radio'];\nvar focusTrapTest = undefined;\n// This query is adapted from a11y-dialog\n// https://github.com/edenspiekermann/a11y-dialog/blob/cf4ed81/a11y-dialog.js#L6-L18\nvar focusablesQuery = 'a[href], area[href], input, select, textarea, ' +\n    'button, iframe, object, embed, [contenteditable], [tabindex], ' +\n    'video[controls], audio[controls], summary';\nfunction getActiveElement() {\n    var activeElement = document.activeElement;\n    while (activeElement.shadowRoot) {\n        activeElement = activeElement.shadowRoot.activeElement;\n    }\n    return activeElement;\n}\nfunction isFocusable(element) {\n    return element.matches(focusablesQuery) &&\n        !element.disabled &&\n        !/^-/.test(element.getAttribute('tabindex') || '') &&\n        !element.hasAttribute('inert') && // see https://github.com/GoogleChrome/inert-polyfill\n        (element.offsetWidth > 0 || element.offsetHeight > 0);\n}\nfunction getFocusTrapParent(element) {\n    if (!focusTrapTest) {\n        return;\n    }\n    var parent = element.parentElement;\n    while (parent) {\n        if (focusTrapTest(parent)) {\n            return parent;\n        }\n        parent = parent.parentElement;\n    }\n}\nfunction shouldIgnoreEvent(activeElement, forwardDirection) {\n    var tagName = activeElement.tagName;\n    var isTextarea = tagName === 'TEXTAREA';\n    var isTextInput = tagName === 'INPUT' &&\n        textInputTypes.indexOf(activeElement.getAttribute('type').toLowerCase()) !== -1;\n    var isContentEditable = activeElement.hasAttribute('contenteditable');\n    if (!isTextarea && !isTextInput && !isContentEditable) {\n        return false;\n    }\n    var selectionStart;\n    var selectionEnd;\n    var len;\n    if (isContentEditable) {\n        var selection = getSelection();\n        selectionStart = selection.anchorOffset;\n        selectionEnd = selection.focusOffset;\n        len = activeElement.textContent.length;\n    }\n    else {\n        selectionStart = activeElement.selectionStart;\n        selectionEnd = activeElement.selectionEnd;\n        len = activeElement.value.length;\n    }\n    // if the cursor is inside of a textarea/input, then don't focus to the next/previous element\n    // unless the cursor is at the beginning or the end\n    if (!forwardDirection && selectionStart === selectionEnd && selectionStart === 0) {\n        return false;\n    }\n    else if (forwardDirection && selectionStart === selectionEnd && selectionStart === len) {\n        return false;\n    }\n    return true;\n}\nfunction getNextCandidateNodeForShadowDomPolyfill(root, targetElement, forwardDirection, filter) {\n    // When the shadydom polyfill is running, we can't use TreeWalker on ShadowRoots because\n    // they aren't real Nodes. So we do this workaround where we run TreeWalker on the\n    // children instead.\n    var nodes = Array.prototype.slice.call(root.querySelectorAll('*'));\n    var idx = nodes.indexOf(targetElement);\n    if (forwardDirection) {\n        nodes = nodes.slice(idx + 1);\n    }\n    else {\n        if (idx === -1) {\n            idx = nodes.length;\n        }\n        nodes = nodes.slice(0, idx);\n        nodes.reverse();\n    }\n    for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        if (node instanceof HTMLElement && filter.acceptNode(node) === NodeFilter.FILTER_ACCEPT) {\n            return node;\n        }\n    }\n    return undefined;\n}\nfunction getNextCandidateNode(root, targetElement, forwardDirection, filter) {\n    var walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, filter);\n    if (targetElement) {\n        walker.currentNode = targetElement;\n    }\n    if (forwardDirection) {\n        return walker.nextNode();\n    }\n    else if (targetElement) {\n        return walker.previousNode();\n    }\n    // iterating backwards through shadow root, use last child\n    return walker.lastChild();\n}\nfunction isShadowDomPolyfill() {\n    return typeof ShadowRoot !== 'undefined' &&\n        // ShadowRoot.polyfill is just a hack for our unit tests\n        ('polyfill' in ShadowRoot || !ShadowRoot.toString().includes('[native code]'));\n}\nfunction getNextNode(root, targetElement, forwardDirection) {\n    var filter = {\n        acceptNode: function (node) {\n            return (node === targetElement || node.shadowRoot || isFocusable(node))\n                ? NodeFilter.FILTER_ACCEPT\n                : NodeFilter.FILTER_SKIP;\n        }\n    };\n    // TODO: remove this when we don't need to support the Shadow DOM polyfill\n    var nextNode = isShadowDomPolyfill() && root instanceof ShadowRoot\n        ? getNextCandidateNodeForShadowDomPolyfill(root, targetElement, forwardDirection, filter)\n        : getNextCandidateNode(root, targetElement, forwardDirection, filter);\n    if (nextNode && nextNode.shadowRoot) { // push into the shadow DOM\n        return getNextNode(nextNode.shadowRoot, null, forwardDirection);\n    }\n    if (!nextNode && root.host) { // pop out of the shadow DOM\n        return getNextNode(root.host.getRootNode(), root.host, forwardDirection);\n    }\n    return nextNode;\n}\nfunction focusNextOrPrevious(event, key) {\n    var activeElement = getActiveElement();\n    var forwardDirection = key === 'ArrowRight';\n    if (shouldIgnoreEvent(activeElement, forwardDirection)) {\n        return;\n    }\n    var root = getFocusTrapParent(activeElement) || activeElement.getRootNode();\n    var nextNode = getNextNode(root, activeElement, forwardDirection);\n    if (nextNode && nextNode !== activeElement) {\n        nextNode.focus();\n        event.preventDefault();\n    }\n}\nfunction handleEnter(event) {\n    var activeElement = getActiveElement();\n    if (activeElement.tagName === 'INPUT' &&\n        checkboxRadioInputTypes.indexOf(activeElement.getAttribute('type').toLowerCase()) !== -1) {\n        // Explicitly override \"enter\" on an input and make it fire the checkbox/radio\n        activeElement.click();\n        event.preventDefault();\n    }\n}\nfunction keyListener(event) {\n    if (event.altKey || event.metaKey || event.ctrlKey) {\n        return; // ignore e.g. Alt-Left and Ctrl-Right, which are used to switch browser tabs or navigate back/forward\n    }\n    var key = event.key;\n    switch (key) {\n        case 'ArrowLeft':\n        case 'ArrowRight': {\n            focusNextOrPrevious(event, key);\n            break;\n        }\n        case 'Enter': {\n            handleEnter(event);\n            break;\n        }\n    }\n}\n/**\n * Start listening for keyboard events. Attaches a listener to the window.\n */\nfunction register() {\n    addEventListener('keydown', keyListener);\n}\n/**\n * Stop listening for keyboard events. Unattaches a listener to the window.\n */\nfunction unregister() {\n    removeEventListener('keydown', keyListener);\n}\n/**\n * Set a focus trap test to identify any focus traps in the DOM, i.e. a top-level DOM node that indicates the root\n * of a focus trap. Once this is set, if focus changes within the focus trap, then will not leave the focus trap.\n * @param test: the test function\n * @see https://w3c.github.io/aria-practices/examples/dialog-modal/dialog.html\n */\nfunction setFocusTrapTest(test) {\n    focusTrapTest = test;\n}\n\nexport { register, setFocusTrapTest, unregister };\n//# sourceMappingURL=index.js.map\n"],"names":["textInputTypes","checkboxRadioInputTypes","focusTrapTest","focusablesQuery","getActiveElement","activeElement","isFocusable","element","getFocusTrapParent","parent","shouldIgnoreEvent","forwardDirection","tagName","isTextarea","isTextInput","isContentEditable","selectionStart","selectionEnd","len","selection","getNextCandidateNodeForShadowDomPolyfill","root","targetElement","filter","nodes","idx","node","getNextCandidateNode","walker","isShadowDomPolyfill","getNextNode","nextNode","focusNextOrPrevious","event","key","handleEnter","keyListener","register","unregister","setFocusTrapTest","test"],"mappings":"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","x_google_ignoreList":[0]}