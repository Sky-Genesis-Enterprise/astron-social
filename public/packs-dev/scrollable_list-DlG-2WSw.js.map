{"version":3,"file":"scrollable_list-DlG-2WSw.js","sources":["../../app/javascript/mastodon/features/ui/util/get_rect_from_entry.js","../../app/javascript/mastodon/components/intersection_observer_article.jsx","../../app/javascript/mastodon/containers/intersection_observer_article_container.js","../../app/javascript/mastodon/features/ui/util/intersection_observer_wrapper.js","../../app/javascript/mastodon/components/load_pending.tsx","../../app/javascript/mastodon/components/scrollable_list.jsx"],"sourcesContent":["\n// Get the bounding client rect from an IntersectionObserver entry.\n// This is to work around a bug in Chrome: https://crbug.com/737228\n\nlet hasBoundingRectBug;\n\nfunction getRectFromEntry(entry) {\n  if (typeof hasBoundingRectBug !== 'boolean') {\n    const boundingRect = entry.target.getBoundingClientRect();\n    const observerRect = entry.boundingClientRect;\n    hasBoundingRectBug = boundingRect.height !== observerRect.height ||\n      boundingRect.top !== observerRect.top ||\n      boundingRect.width !== observerRect.width ||\n      boundingRect.bottom !== observerRect.bottom ||\n      boundingRect.left !== observerRect.left ||\n      boundingRect.right !== observerRect.right;\n  }\n  return hasBoundingRectBug ? entry.target.getBoundingClientRect() : entry.boundingClientRect;\n}\n\nexport default getRectFromEntry;\n","import PropTypes from 'prop-types';\nimport { cloneElement, Component } from 'react';\n\nimport getRectFromEntry from '../features/ui/util/get_rect_from_entry';\nimport scheduleIdleTask from '../features/ui/util/schedule_idle_task';\n\n// Diff these props in the \"unrendered\" state\nconst updateOnPropsForUnrendered = ['id', 'index', 'listLength', 'cachedHeight'];\n\nexport default class IntersectionObserverArticle extends Component {\n\n  static propTypes = {\n    intersectionObserverWrapper: PropTypes.object.isRequired,\n    id: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n    index: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n    listLength: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n    saveHeightKey: PropTypes.string,\n    cachedHeight: PropTypes.number,\n    onHeightChange: PropTypes.func,\n    children: PropTypes.node,\n  };\n\n  state = {\n    isHidden: false, // set to true in requestIdleCallback to trigger un-render\n  };\n\n  shouldComponentUpdate (nextProps, nextState) {\n    const isUnrendered = !this.state.isIntersecting && (this.state.isHidden || this.props.cachedHeight);\n    const willBeUnrendered = !nextState.isIntersecting && (nextState.isHidden || nextProps.cachedHeight);\n    if (!!isUnrendered !== !!willBeUnrendered) {\n      // If we're going from rendered to unrendered (or vice versa) then update\n      return true;\n    }\n    // If we are and remain hidden, diff based on props\n    if (isUnrendered) {\n      return !updateOnPropsForUnrendered.every(prop => nextProps[prop] === this.props[prop]);\n    }\n    // Else, assume the children have changed\n    return true;\n  }\n\n  componentDidMount () {\n    const { intersectionObserverWrapper, id } = this.props;\n\n    intersectionObserverWrapper.observe(\n      id,\n      this.node,\n      this.handleIntersection,\n    );\n\n    this.componentMounted = true;\n  }\n\n  componentWillUnmount () {\n    const { intersectionObserverWrapper, id } = this.props;\n    intersectionObserverWrapper.unobserve(id, this.node);\n\n    this.componentMounted = false;\n  }\n\n  handleIntersection = (entry) => {\n    this.entry = entry;\n\n    scheduleIdleTask(this.calculateHeight);\n    this.setState(this.updateStateAfterIntersection);\n  };\n\n  updateStateAfterIntersection = (prevState) => {\n    if (prevState.isIntersecting !== false && !this.entry.isIntersecting) {\n      scheduleIdleTask(this.hideIfNotIntersecting);\n    }\n    return {\n      isIntersecting: this.entry.isIntersecting,\n      isHidden: false,\n    };\n  };\n\n  calculateHeight = () => {\n    const { onHeightChange, saveHeightKey, id } = this.props;\n    // save the height of the fully-rendered element (this is expensive\n    // on Chrome, where we need to fall back to getBoundingClientRect)\n    this.height = getRectFromEntry(this.entry).height;\n\n    if (onHeightChange && saveHeightKey) {\n      onHeightChange(saveHeightKey, id, this.height);\n    }\n  };\n\n  hideIfNotIntersecting = () => {\n    if (!this.componentMounted) {\n      return;\n    }\n\n    // When the browser gets a chance, test if we're still not intersecting,\n    // and if so, set our isHidden to true to trigger an unrender. The point of\n    // this is to save DOM nodes and avoid using up too much memory.\n    // See: https://github.com/mastodon/mastodon/issues/2900\n    this.setState((prevState) => ({ isHidden: !prevState.isIntersecting }));\n  };\n\n  handleRef = (node) => {\n    this.node = node;\n  };\n\n  render () {\n    const { children, id, index, listLength, cachedHeight } = this.props;\n    const { isIntersecting, isHidden } = this.state;\n\n    if (!isIntersecting && (isHidden || cachedHeight)) {\n      return (\n        <article\n          ref={this.handleRef}\n          aria-posinset={index + 1}\n          aria-setsize={listLength}\n          style={{ height: `${this.height || cachedHeight}px`, opacity: 0, overflow: 'hidden' }}\n          data-id={id}\n          tabIndex={-1}\n        >\n          {children && cloneElement(children, { hidden: true })}\n        </article>\n      );\n    }\n\n    return (\n      <article ref={this.handleRef} aria-posinset={index + 1} aria-setsize={listLength} data-id={id} tabIndex={-1}>\n        {children && cloneElement(children, { hidden: false })}\n      </article>\n    );\n  }\n\n}\n","import { connect } from 'react-redux';\n\nimport { setHeight } from '../actions/height_cache';\nimport IntersectionObserverArticle from '../components/intersection_observer_article';\n\nconst makeMapStateToProps = (state, props) => ({\n  cachedHeight: state.getIn(['height_cache', props.saveHeightKey, props.id]),\n});\n\nconst mapDispatchToProps = (dispatch) => ({\n\n  onHeightChange (key, id, height) {\n    dispatch(setHeight(key, id, height));\n  },\n\n});\n\nexport default connect(makeMapStateToProps, mapDispatchToProps)(IntersectionObserverArticle);\n","// Wrapper for IntersectionObserver in order to make working with it\n// a bit easier. We also follow this performance advice:\n// \"If you need to observe multiple elements, it is both possible and\n// advised to observe multiple elements using the same IntersectionObserver\n// instance by calling observe() multiple times.\"\n// https://developers.google.com/web/updates/2016/04/intersectionobserver\n\nclass IntersectionObserverWrapper {\n\n  callbacks = {};\n  observerBacklog = [];\n  observer = null;\n\n  connect (options) {\n    const onIntersection = (entries) => {\n      entries.forEach(entry => {\n        const id = entry.target.getAttribute('data-id');\n        if (this.callbacks[id]) {\n          this.callbacks[id](entry);\n        }\n      });\n    };\n\n    this.observer = new IntersectionObserver(onIntersection, options);\n    this.observerBacklog.forEach(([ id, node, callback ]) => {\n      this.observe(id, node, callback);\n    });\n    this.observerBacklog = null;\n  }\n\n  observe (id, node, callback) {\n    if (!this.observer) {\n      this.observerBacklog.push([ id, node, callback ]);\n    } else {\n      this.callbacks[id] = callback;\n      this.observer.observe(node);\n    }\n  }\n\n  unobserve (id, node) {\n    if (this.observer) {\n      delete this.callbacks[id];\n      this.observer.unobserve(node);\n    }\n  }\n\n  disconnect () {\n    if (this.observer) {\n      this.callbacks = {};\n      this.observer.disconnect();\n      this.observer = null;\n    }\n  }\n\n}\n\nexport default IntersectionObserverWrapper;\n","import { FormattedMessage } from 'react-intl';\n\ninterface Props {\n  onClick: (event: React.MouseEvent) => void;\n  count: number;\n}\n\nexport const LoadPending: React.FC<Props> = ({ onClick, count }) => {\n  return (\n    <button className='load-more load-gap' onClick={onClick}>\n      <FormattedMessage\n        id='load_pending'\n        defaultMessage='{count, plural, one {# new item} other {# new items}}'\n        values={{ count }}\n      />\n    </button>\n  );\n};\n","import PropTypes from 'prop-types';\nimport { Children, cloneElement, PureComponent } from 'react';\n\nimport classNames from 'classnames';\nimport { useLocation } from 'react-router-dom';\n\nimport { List as ImmutableList } from 'immutable';\nimport { connect } from 'react-redux';\n\nimport { supportsPassiveEvents } from 'detect-passive-events';\nimport { throttle } from 'lodash';\n\nimport ScrollContainer from 'mastodon/containers/scroll_container';\n\nimport IntersectionObserverArticleContainer from '../containers/intersection_observer_article_container';\nimport { attachFullscreenListener, detachFullscreenListener, isFullscreen } from '../features/ui/util/fullscreen';\nimport IntersectionObserverWrapper from '../features/ui/util/intersection_observer_wrapper';\n\nimport { LoadMore } from './load_more';\nimport { LoadPending } from './load_pending';\nimport { LoadingIndicator } from './loading_indicator';\n\nconst MOUSE_IDLE_DELAY = 300;\n\nconst listenerOptions = supportsPassiveEvents ? { passive: true } : false;\n\n/**\n *\n * @param {import('mastodon/store').RootState} state\n * @param {*} props\n */\nconst mapStateToProps = (state, { scrollKey }) => {\n  return {\n    preventScroll: scrollKey === state.dropdownMenu.scrollKey,\n  };\n};\n\n// This component only exists to be able to call useLocation()\nconst IOArticleContainerWrapper = ({id, index, listLength, intersectionObserverWrapper, trackScroll, scrollKey, children}) => {\n  const location = useLocation();\n\n  return (<IntersectionObserverArticleContainer\n    id={id}\n    index={index}\n    listLength={listLength}\n    intersectionObserverWrapper={intersectionObserverWrapper}\n    saveHeightKey={trackScroll ? `${location.key}:${scrollKey}` : null}\n  >\n    {children}\n  </IntersectionObserverArticleContainer>);\n};\n\nIOArticleContainerWrapper.propTypes =  {\n  id: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  index: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  listLength: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  scrollKey: PropTypes.string.isRequired,\n  intersectionObserverWrapper: PropTypes.object.isRequired,\n  trackScroll: PropTypes.bool.isRequired,\n  children: PropTypes.node,\n};\n\nclass ScrollableList extends PureComponent {\n\n  static propTypes = {\n    scrollKey: PropTypes.string.isRequired,\n    onLoadMore: PropTypes.func,\n    onLoadPending: PropTypes.func,\n    onScrollToTop: PropTypes.func,\n    onScroll: PropTypes.func,\n    trackScroll: PropTypes.bool,\n    isLoading: PropTypes.bool,\n    showLoading: PropTypes.bool,\n    hasMore: PropTypes.bool,\n    numPending: PropTypes.number,\n    prepend: PropTypes.node,\n    append: PropTypes.node,\n    alwaysPrepend: PropTypes.bool,\n    emptyMessage: PropTypes.node,\n    children: PropTypes.node,\n    bindToDocument: PropTypes.bool,\n    preventScroll: PropTypes.bool,\n    footer: PropTypes.node,\n    className: PropTypes.string,\n  };\n\n  static defaultProps = {\n    trackScroll: true,\n  };\n\n  state = {\n    fullscreen: null,\n    cachedMediaWidth: 250, // Default media/card width using default Mastodon theme\n  };\n\n  intersectionObserverWrapper = new IntersectionObserverWrapper();\n\n  handleScroll = throttle(() => {\n    if (this.node) {\n      const scrollTop = this.getScrollTop();\n      const scrollHeight = this.getScrollHeight();\n      const clientHeight = this.getClientHeight();\n      const offset = scrollHeight - scrollTop - clientHeight;\n\n      if (scrollTop > 0 && offset < 400 && this.props.onLoadMore && this.props.hasMore && !this.props.isLoading) {\n        this.props.onLoadMore();\n      }\n\n      if (scrollTop < 100 && this.props.onScrollToTop) {\n        this.props.onScrollToTop();\n      } else if (this.props.onScroll) {\n        this.props.onScroll();\n      }\n\n      if (!this.lastScrollWasSynthetic) {\n        // If the last scroll wasn't caused by setScrollTop(), assume it was\n        // intentional and cancel any pending scroll reset on mouse idle\n        this.scrollToTopOnMouseIdle = false;\n      }\n      this.lastScrollWasSynthetic = false;\n    }\n  }, 150, {\n    trailing: true,\n  });\n\n  mouseIdleTimer = null;\n  mouseMovedRecently = false;\n  lastScrollWasSynthetic = false;\n  scrollToTopOnMouseIdle = false;\n\n  _getScrollingElement = () => {\n    if (this.props.bindToDocument) {\n      return (document.scrollingElement || document.body);\n    } else {\n      return this.node;\n    }\n  };\n\n  setScrollTop = newScrollTop => {\n    if (this.getScrollTop() !== newScrollTop) {\n      this.lastScrollWasSynthetic = true;\n\n      this._getScrollingElement().scrollTop = newScrollTop;\n    }\n  };\n\n  clearMouseIdleTimer = () => {\n    if (this.mouseIdleTimer === null) {\n      return;\n    }\n\n    clearTimeout(this.mouseIdleTimer);\n    this.mouseIdleTimer = null;\n  };\n\n  handleMouseMove = throttle(() => {\n    // As long as the mouse keeps moving, clear and restart the idle timer.\n    this.clearMouseIdleTimer();\n    this.mouseIdleTimer = setTimeout(this.handleMouseIdle, MOUSE_IDLE_DELAY);\n\n    if (!this.mouseMovedRecently && this.getScrollTop() === 0) {\n      // Only set if we just started moving and are scrolled to the top.\n      this.scrollToTopOnMouseIdle = true;\n    }\n\n    // Save setting this flag for last, so we can do the comparison above.\n    this.mouseMovedRecently = true;\n  }, MOUSE_IDLE_DELAY / 2);\n\n  handleWheel = throttle(() => {\n    this.scrollToTopOnMouseIdle = false;\n  }, 150, {\n    trailing: true,\n  });\n\n  handleMouseIdle = () => {\n    if (this.scrollToTopOnMouseIdle && !this.props.preventScroll) {\n      this.setScrollTop(0);\n    }\n\n    this.mouseMovedRecently = false;\n    this.scrollToTopOnMouseIdle = false;\n  };\n\n  componentDidMount () {\n    this.attachScrollListener();\n    this.attachIntersectionObserver();\n\n    attachFullscreenListener(this.onFullScreenChange);\n\n    // Handle initial scroll position\n    this.handleScroll();\n  }\n\n  getScrollPosition = () => {\n    if (this.node && (this.getScrollTop() > 0 || this.mouseMovedRecently)) {\n      return { height: this.getScrollHeight(), top: this.getScrollTop() };\n    } else {\n      return null;\n    }\n  };\n\n  getScrollTop = () => {\n    return this._getScrollingElement().scrollTop;\n  };\n\n  getScrollHeight = () => {\n    return this._getScrollingElement().scrollHeight;\n  };\n\n  getClientHeight = () => {\n    return this._getScrollingElement().clientHeight;\n  };\n\n  updateScrollBottom = (snapshot) => {\n    const newScrollTop = this.getScrollHeight() - snapshot;\n\n    this.setScrollTop(newScrollTop);\n  };\n\n  getSnapshotBeforeUpdate (prevProps) {\n    const someItemInserted = Children.count(prevProps.children) > 0 &&\n      Children.count(prevProps.children) < Children.count(this.props.children) &&\n      this.getFirstChildKey(prevProps) !== this.getFirstChildKey(this.props);\n    const pendingChanged = (prevProps.numPending > 0) !== (this.props.numPending > 0);\n\n    if (pendingChanged || someItemInserted && (this.getScrollTop() > 0 || this.mouseMovedRecently || this.props.preventScroll)) {\n      return this.getScrollHeight() - this.getScrollTop();\n    } else {\n      return null;\n    }\n  }\n\n  componentDidUpdate (prevProps, prevState, snapshot) {\n    // Reset the scroll position when a new child comes in in order not to\n    // jerk the scrollbar around if you're already scrolled down the page.\n    if (snapshot !== null) {\n      this.setScrollTop(this.getScrollHeight() - snapshot);\n    }\n  }\n\n  cacheMediaWidth = (width) => {\n    if (width && this.state.cachedMediaWidth !== width) {\n      this.setState({ cachedMediaWidth: width });\n    }\n  };\n\n  componentWillUnmount () {\n    this.clearMouseIdleTimer();\n    this.detachScrollListener();\n    this.detachIntersectionObserver();\n\n    detachFullscreenListener(this.onFullScreenChange);\n  }\n\n  onFullScreenChange = () => {\n    this.setState({ fullscreen: isFullscreen() });\n  };\n\n  attachIntersectionObserver () {\n    let nodeOptions = {\n      root: this.node,\n      rootMargin: '300% 0px',\n    };\n\n    this.intersectionObserverWrapper\n      .connect(this.props.bindToDocument ? {} : nodeOptions);\n  }\n\n  detachIntersectionObserver () {\n    this.intersectionObserverWrapper.disconnect();\n  }\n\n  attachScrollListener () {\n    if (this.props.bindToDocument) {\n      document.addEventListener('scroll', this.handleScroll);\n      document.addEventListener('wheel', this.handleWheel,  listenerOptions);\n    } else {\n      this.node.addEventListener('scroll', this.handleScroll);\n      this.node.addEventListener('wheel', this.handleWheel, listenerOptions);\n    }\n  }\n\n  detachScrollListener () {\n    if (this.props.bindToDocument) {\n      document.removeEventListener('scroll', this.handleScroll);\n      document.removeEventListener('wheel', this.handleWheel, listenerOptions);\n    } else {\n      this.node.removeEventListener('scroll', this.handleScroll);\n      this.node.removeEventListener('wheel', this.handleWheel, listenerOptions);\n    }\n  }\n\n  getFirstChildKey (props) {\n    const { children } = props;\n    let firstChild     = children;\n\n    if (children instanceof ImmutableList) {\n      firstChild = children.get(0);\n    } else if (Array.isArray(children)) {\n      firstChild = children[0];\n    }\n\n    return firstChild && firstChild.key;\n  }\n\n  setRef = (c) => {\n    this.node = c;\n  };\n\n  handleLoadMore = e => {\n    e.preventDefault();\n    this.props.onLoadMore();\n  };\n\n  handleLoadPending = e => {\n    e.preventDefault();\n    this.props.onLoadPending();\n    // Prevent the weird scroll-jumping behavior, as we explicitly don't want to\n    // scroll to top, and we know the scroll height is going to change\n    this.scrollToTopOnMouseIdle = false;\n    this.lastScrollWasSynthetic = false;\n    this.clearMouseIdleTimer();\n    this.mouseIdleTimer = setTimeout(this.handleMouseIdle, MOUSE_IDLE_DELAY);\n    this.mouseMovedRecently = true;\n  };\n\n  render () {\n    const { children, scrollKey, className, trackScroll, showLoading, isLoading, hasMore, numPending, prepend, alwaysPrepend, append, footer, emptyMessage, onLoadMore } = this.props;\n    const { fullscreen } = this.state;\n    const childrenCount = Children.count(children);\n\n    const loadMore     = (hasMore && onLoadMore) ? <LoadMore visible={!isLoading} onClick={this.handleLoadMore} /> : null;\n    const loadPending  = (numPending > 0) ? <LoadPending count={numPending} onClick={this.handleLoadPending} /> : null;\n    let scrollableArea = null;\n\n    if (showLoading) {\n      scrollableArea = (\n        <div className='scrollable scrollable--flex' ref={this.setRef}>\n          {prepend}\n\n          <div role='feed' className='item-list' />\n\n          <div className='scrollable__append'>\n            <LoadingIndicator />\n          </div>\n\n          {footer}\n        </div>\n      );\n    } else if (isLoading || childrenCount > 0 || numPending > 0 || hasMore || !emptyMessage) {\n      scrollableArea = (\n        <div className={classNames('scrollable scrollable--flex', { fullscreen })} ref={this.setRef} onMouseMove={this.handleMouseMove}>\n          {prepend}\n\n          <div role='feed' className={classNames('item-list', className)}>\n            {loadPending}\n\n            {Children.map(this.props.children, (child, index) => (\n              <IOArticleContainerWrapper\n                key={child.key}\n                id={child.key}\n                index={index}\n                listLength={childrenCount}\n                intersectionObserverWrapper={this.intersectionObserverWrapper}\n                trackScroll={trackScroll}\n                scrollKey={scrollKey}\n              >\n                {cloneElement(child, {\n                  getScrollPosition: this.getScrollPosition,\n                  updateScrollBottom: this.updateScrollBottom,\n                  cachedMediaWidth: this.state.cachedMediaWidth,\n                  cacheMediaWidth: this.cacheMediaWidth,\n                })}\n              </IOArticleContainerWrapper>\n            ))}\n\n            {loadMore}\n\n            {!hasMore && append}\n          </div>\n\n          {footer}\n        </div>\n      );\n    } else {\n      scrollableArea = (\n        <div className={classNames('scrollable scrollable--flex', { fullscreen })} ref={this.setRef}>\n          {alwaysPrepend && prepend}\n\n          <div className='empty-column-indicator'>\n            {emptyMessage}\n          </div>\n\n          {footer}\n        </div>\n      );\n    }\n\n    if (trackScroll) {\n      return (\n        <ScrollContainer scrollKey={scrollKey}>\n          {scrollableArea}\n        </ScrollContainer>\n      );\n    } else {\n      return scrollableArea;\n    }\n  }\n\n}\n\nexport default connect(mapStateToProps, null, null, { forwardRef: true })(ScrollableList);\n"],"names":["hasBoundingRectBug","getRectFromEntry","entry","boundingRect","target","getBoundingClientRect","observerRect","boundingClientRect","height","top","width","bottom","left","right","updateOnPropsForUnrendered","IntersectionObserverArticle","Component","state","isHidden","handleIntersection","scheduleIdleTask","calculateHeight","setState","updateStateAfterIntersection","prevState","isIntersecting","hideIfNotIntersecting","onHeightChange","saveHeightKey","id","props","componentMounted","handleRef","node","shouldComponentUpdate","nextProps","nextState","isUnrendered","cachedHeight","willBeUnrendered","every","prop","componentDidMount","intersectionObserverWrapper","observe","componentWillUnmount","unobserve","render","children","index","listLength","jsxDEV","opacity","overflow","cloneElement","hidden","makeMapStateToProps","getIn","mapDispatchToProps","dispatch","key","setHeight","IntersectionObserverArticleContainer","connect","IntersectionObserverWrapper","callbacks","observerBacklog","observer","options","onIntersection","entries","forEach","getAttribute","IntersectionObserver","callback","push","disconnect","LoadPending","onClick","count","FormattedMessage","this","MOUSE_IDLE_DELAY","listenerOptions","supportsPassiveEvents","passive","mapStateToProps","scrollKey","preventScroll","dropdownMenu","IOArticleContainerWrapper","trackScroll","location","useLocation","ScrollableList","PureComponent","fullscreen","cachedMediaWidth","handleScroll","throttle","scrollTop","getScrollTop","scrollHeight","getScrollHeight","clientHeight","getClientHeight","offset","onLoadMore","hasMore","isLoading","onScrollToTop","onScroll","lastScrollWasSynthetic","scrollToTopOnMouseIdle","trailing","mouseIdleTimer","mouseMovedRecently","_getScrollingElement","bindToDocument","document","scrollingElement","body","setScrollTop","newScrollTop","clearMouseIdleTimer","clearTimeout","handleMouseMove","setTimeout","handleMouseIdle","handleWheel","getScrollPosition","updateScrollBottom","snapshot","cacheMediaWidth","onFullScreenChange","isFullscreen","setRef","c","handleLoadMore","e","preventDefault","handleLoadPending","onLoadPending","attachScrollListener","attachIntersectionObserver","attachFullscreenListener","getSnapshotBeforeUpdate","prevProps","someItemInserted","Children","getFirstChildKey","numPending","componentDidUpdate","detachScrollListener","detachIntersectionObserver","detachFullscreenListener","nodeOptions","root","rootMargin","addEventListener","removeEventListener","firstChild","ImmutableList","get","Array","isArray","className","showLoading","prepend","alwaysPrepend","append","footer","emptyMessage","childrenCount","loadMore","LoadMore","loadPending","scrollableArea","LoadingIndicator","classNames","map","child","ScrollContainer","__publicField","defaultProps","ScrollableList$1","forwardRef"],"mappings":"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"}