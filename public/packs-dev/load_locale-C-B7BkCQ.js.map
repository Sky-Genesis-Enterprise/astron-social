{"version":3,"mappings":"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","names":["isDevelopment","process","isProduction","loadedLocale","setLocale","locale","getLocale","Error","messages","isLocaleLoaded","E_CANCELED","__awaiter$2","thisArg","_arguments","P","generator","adopt","value","resolve","reject","fulfilled","step","e","rejected","result","Semaphore","_value","_cancelError","weight","priority","task","i","findIndexFromEnd","other","callback_1","callback","release","insertSorted","entry","item","previousValue","called","waiters","waiter","queuedPriority","a","v","predicate","localeLoadingSemaphore","localeFiles","import","loadLocale","document","querySelector","lang","runExclusive","localeFile","Object","hasOwn","default","localeData"],"ignoreList":[2],"sources":["../../app/javascript/mastodon/utils/environment.ts","../../app/javascript/mastodon/locales/global_locale.ts","../../node_modules/async-mutex/index.mjs","../../app/javascript/mastodon/locales/load_locale.ts"],"sourcesContent":["export function isDevelopment() {\n  if (typeof process !== 'undefined')\n    return process.env.NODE_ENV === 'development';\n  else return import.meta.env.DEV;\n}\n\nexport function isProduction() {\n  if (typeof process !== 'undefined')\n    return process.env.NODE_ENV === 'production';\n  else return import.meta.env.PROD;\n}\n","import { isDevelopment } from 'mastodon/utils/environment';\n\nexport interface LocaleData {\n  locale: string;\n  messages: Record<string, string>;\n}\n\nlet loadedLocale: LocaleData | undefined;\n\nexport function setLocale(locale: LocaleData) {\n  loadedLocale = locale;\n}\n\nexport function getLocale(): LocaleData {\n  if (!loadedLocale) {\n    if (isDevelopment()) {\n      throw new Error('getLocale() called before any locale has been set');\n    } else {\n      return { locale: 'unknown', messages: {} };\n    }\n  }\n\n  return loadedLocale;\n}\n\nexport function isLocaleLoaded() {\n  return !!loadedLocale;\n}\n","const E_TIMEOUT = new Error('timeout while waiting for mutex to become available');\nconst E_ALREADY_LOCKED = new Error('mutex already locked');\nconst E_CANCELED = new Error('request for lock canceled');\n\nvar __awaiter$2 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass Semaphore {\n    constructor(_value, _cancelError = E_CANCELED) {\n        this._value = _value;\n        this._cancelError = _cancelError;\n        this._queue = [];\n        this._weightedWaiters = [];\n    }\n    acquire(weight = 1, priority = 0) {\n        if (weight <= 0)\n            throw new Error(`invalid weight ${weight}: must be positive`);\n        return new Promise((resolve, reject) => {\n            const task = { resolve, reject, weight, priority };\n            const i = findIndexFromEnd(this._queue, (other) => priority <= other.priority);\n            if (i === -1 && weight <= this._value) {\n                // Needs immediate dispatch, skip the queue\n                this._dispatchItem(task);\n            }\n            else {\n                this._queue.splice(i + 1, 0, task);\n            }\n        });\n    }\n    runExclusive(callback_1) {\n        return __awaiter$2(this, arguments, void 0, function* (callback, weight = 1, priority = 0) {\n            const [value, release] = yield this.acquire(weight, priority);\n            try {\n                return yield callback(value);\n            }\n            finally {\n                release();\n            }\n        });\n    }\n    waitForUnlock(weight = 1, priority = 0) {\n        if (weight <= 0)\n            throw new Error(`invalid weight ${weight}: must be positive`);\n        if (this._couldLockImmediately(weight, priority)) {\n            return Promise.resolve();\n        }\n        else {\n            return new Promise((resolve) => {\n                if (!this._weightedWaiters[weight - 1])\n                    this._weightedWaiters[weight - 1] = [];\n                insertSorted(this._weightedWaiters[weight - 1], { resolve, priority });\n            });\n        }\n    }\n    isLocked() {\n        return this._value <= 0;\n    }\n    getValue() {\n        return this._value;\n    }\n    setValue(value) {\n        this._value = value;\n        this._dispatchQueue();\n    }\n    release(weight = 1) {\n        if (weight <= 0)\n            throw new Error(`invalid weight ${weight}: must be positive`);\n        this._value += weight;\n        this._dispatchQueue();\n    }\n    cancel() {\n        this._queue.forEach((entry) => entry.reject(this._cancelError));\n        this._queue = [];\n    }\n    _dispatchQueue() {\n        this._drainUnlockWaiters();\n        while (this._queue.length > 0 && this._queue[0].weight <= this._value) {\n            this._dispatchItem(this._queue.shift());\n            this._drainUnlockWaiters();\n        }\n    }\n    _dispatchItem(item) {\n        const previousValue = this._value;\n        this._value -= item.weight;\n        item.resolve([previousValue, this._newReleaser(item.weight)]);\n    }\n    _newReleaser(weight) {\n        let called = false;\n        return () => {\n            if (called)\n                return;\n            called = true;\n            this.release(weight);\n        };\n    }\n    _drainUnlockWaiters() {\n        if (this._queue.length === 0) {\n            for (let weight = this._value; weight > 0; weight--) {\n                const waiters = this._weightedWaiters[weight - 1];\n                if (!waiters)\n                    continue;\n                waiters.forEach((waiter) => waiter.resolve());\n                this._weightedWaiters[weight - 1] = [];\n            }\n        }\n        else {\n            const queuedPriority = this._queue[0].priority;\n            for (let weight = this._value; weight > 0; weight--) {\n                const waiters = this._weightedWaiters[weight - 1];\n                if (!waiters)\n                    continue;\n                const i = waiters.findIndex((waiter) => waiter.priority <= queuedPriority);\n                (i === -1 ? waiters : waiters.splice(0, i))\n                    .forEach((waiter => waiter.resolve()));\n            }\n        }\n    }\n    _couldLockImmediately(weight, priority) {\n        return (this._queue.length === 0 || this._queue[0].priority < priority) &&\n            weight <= this._value;\n    }\n}\nfunction insertSorted(a, v) {\n    const i = findIndexFromEnd(a, (other) => v.priority <= other.priority);\n    a.splice(i + 1, 0, v);\n}\nfunction findIndexFromEnd(a, predicate) {\n    for (let i = a.length - 1; i >= 0; i--) {\n        if (predicate(a[i])) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nvar __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass Mutex {\n    constructor(cancelError) {\n        this._semaphore = new Semaphore(1, cancelError);\n    }\n    acquire() {\n        return __awaiter$1(this, arguments, void 0, function* (priority = 0) {\n            const [, releaser] = yield this._semaphore.acquire(1, priority);\n            return releaser;\n        });\n    }\n    runExclusive(callback, priority = 0) {\n        return this._semaphore.runExclusive(() => callback(), 1, priority);\n    }\n    isLocked() {\n        return this._semaphore.isLocked();\n    }\n    waitForUnlock(priority = 0) {\n        return this._semaphore.waitForUnlock(1, priority);\n    }\n    release() {\n        if (this._semaphore.isLocked())\n            this._semaphore.release();\n    }\n    cancel() {\n        return this._semaphore.cancel();\n    }\n}\n\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nfunction withTimeout(sync, timeout, timeoutError = E_TIMEOUT) {\n    return {\n        acquire: (weightOrPriority, priority) => {\n            let weight;\n            if (isSemaphore(sync)) {\n                weight = weightOrPriority;\n            }\n            else {\n                weight = undefined;\n                priority = weightOrPriority;\n            }\n            if (weight !== undefined && weight <= 0) {\n                throw new Error(`invalid weight ${weight}: must be positive`);\n            }\n            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                let isTimeout = false;\n                const handle = setTimeout(() => {\n                    isTimeout = true;\n                    reject(timeoutError);\n                }, timeout);\n                try {\n                    const ticket = yield (isSemaphore(sync)\n                        ? sync.acquire(weight, priority)\n                        : sync.acquire(priority));\n                    if (isTimeout) {\n                        const release = Array.isArray(ticket) ? ticket[1] : ticket;\n                        release();\n                    }\n                    else {\n                        clearTimeout(handle);\n                        resolve(ticket);\n                    }\n                }\n                catch (e) {\n                    if (!isTimeout) {\n                        clearTimeout(handle);\n                        reject(e);\n                    }\n                }\n            }));\n        },\n        runExclusive(callback, weight, priority) {\n            return __awaiter(this, void 0, void 0, function* () {\n                let release = () => undefined;\n                try {\n                    const ticket = yield this.acquire(weight, priority);\n                    if (Array.isArray(ticket)) {\n                        release = ticket[1];\n                        return yield callback(ticket[0]);\n                    }\n                    else {\n                        release = ticket;\n                        return yield callback();\n                    }\n                }\n                finally {\n                    release();\n                }\n            });\n        },\n        release(weight) {\n            sync.release(weight);\n        },\n        cancel() {\n            return sync.cancel();\n        },\n        waitForUnlock: (weightOrPriority, priority) => {\n            let weight;\n            if (isSemaphore(sync)) {\n                weight = weightOrPriority;\n            }\n            else {\n                weight = undefined;\n                priority = weightOrPriority;\n            }\n            if (weight !== undefined && weight <= 0) {\n                throw new Error(`invalid weight ${weight}: must be positive`);\n            }\n            return new Promise((resolve, reject) => {\n                const handle = setTimeout(() => reject(timeoutError), timeout);\n                (isSemaphore(sync)\n                    ? sync.waitForUnlock(weight, priority)\n                    : sync.waitForUnlock(priority)).then(() => {\n                    clearTimeout(handle);\n                    resolve();\n                });\n            });\n        },\n        isLocked: () => sync.isLocked(),\n        getValue: () => sync.getValue(),\n        setValue: (value) => sync.setValue(value),\n    };\n}\nfunction isSemaphore(sync) {\n    return sync.getValue !== undefined;\n}\n\n// eslint-disable-next-lisne @typescript-eslint/explicit-module-boundary-types\nfunction tryAcquire(sync, alreadyAcquiredError = E_ALREADY_LOCKED) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return withTimeout(sync, 0, alreadyAcquiredError);\n}\n\nexport { E_ALREADY_LOCKED, E_CANCELED, E_TIMEOUT, Mutex, Semaphore, tryAcquire, withTimeout };\n","import { Semaphore } from 'async-mutex';\n\nimport type { LocaleData } from './global_locale';\nimport { isLocaleLoaded, setLocale } from './global_locale';\n\nconst localeLoadingSemaphore = new Semaphore(1);\n\nconst localeFiles = import.meta.glob<{ default: LocaleData['messages'] }>([\n  './*.json',\n]);\n\nexport async function loadLocale() {\n  // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing -- we want to match empty strings\n  const locale = document.querySelector<HTMLElement>('html')?.lang || 'en';\n\n  // We use a Semaphore here so only one thing can try to load the locales at\n  // the same time. If one tries to do it while its in progress, it will wait\n  // for the initial load to finish before it is resumed (and will see that locale\n  // data is already loaded)\n  await localeLoadingSemaphore.runExclusive(async () => {\n    // if the locale is already set, then do nothing\n    if (isLocaleLoaded()) return;\n\n    // If there is no locale file, then fallback to english\n    const localeFile = Object.hasOwn(localeFiles, `./${locale}.json`)\n      ? localeFiles[`./${locale}.json`]\n      : localeFiles['./en.json'];\n\n    if (!localeFile) throw new Error('Could not load the locale JSON file');\n\n    const { default: localeData } = await localeFile();\n\n    setLocale({ messages: localeData, locale });\n  });\n}\n"],"file":"load_locale-C-B7BkCQ.js"}