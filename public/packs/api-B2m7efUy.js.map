{"version":3,"file":"api-B2m7efUy.js","sources":["../../node_modules/http-link-header/lib/link.js","../../app/javascript/mastodon/api.ts"],"sourcesContent":["'use strict'\n\nvar COMPATIBLE_ENCODING_PATTERN = /^utf-?8|ascii|utf-?16-?le|ucs-?2|base-?64|latin-?1$/i\nvar WS_TRIM_PATTERN = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g\nvar WS_CHAR_PATTERN = /\\s|\\uFEFF|\\xA0/\nvar WS_FOLD_PATTERN = /\\r?\\n[\\x20\\x09]+/g\nvar DELIMITER_PATTERN = /[;,\"]/\nvar WS_DELIMITER_PATTERN = /[;,\"]|\\s/\n\n/**\n * Token character pattern\n * @type {RegExp}\n * @see https://tools.ietf.org/html/rfc7230#section-3.2.6\n */\nvar TOKEN_PATTERN = /^[!#$%&'*+\\-\\.^_`|~\\da-zA-Z]+$/\n\nvar STATE = {\n  IDLE: 1 << 0,\n  URI: 1 << 1,\n  ATTR: 1 << 2,\n}\n\nfunction trim( value ) {\n  return value.replace( WS_TRIM_PATTERN, '' )\n}\n\nfunction hasWhitespace( value ) {\n  return WS_CHAR_PATTERN.test( value )\n}\n\nfunction skipWhitespace( value, offset ) {\n  while( hasWhitespace( value[offset] ) ) {\n    offset++\n  }\n  return offset\n}\n\nfunction needsQuotes( value ) {\n  return WS_DELIMITER_PATTERN.test( value ) ||\n    !TOKEN_PATTERN.test( value )\n}\n\n/**\n * Shallow compares two objects to check if their properties match.\n * @param {object} object1 First object to compare.\n * @param {object} object2 Second object to compare.\n * @returns {boolean} Do the objects have matching properties.\n */\nfunction shallowCompareObjects( object1, object2 ) {\n  return (\n    Object.keys( object1 ).length === Object.keys( object2 ).length &&\n    Object.keys( object1 ).every(\n      ( key ) => key in object2 && object1[ key ] === object2[ key ]\n    )\n  );\n}\n\nclass Link {\n\n  /**\n   * Link\n   * @constructor\n   * @param {String} [value]\n   * @returns {Link}\n   */\n  constructor( value ) {\n\n    /** @type {Array} URI references */\n    this.refs = []\n\n    if( value ) {\n      this.parse( value )\n    }\n\n  }\n\n  /**\n   * Get refs with given relation type\n   * @param {String} value\n   * @returns {Array<Object>}\n   */\n  rel( value ) {\n\n    var links = []\n    var type = value.toLowerCase()\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      if( typeof this.refs[ i ].rel === 'string' && this.refs[ i ].rel.toLowerCase() === type ) {\n        links.push( this.refs[ i ] )\n      }\n    }\n\n    return links\n\n  }\n\n  /**\n   * Get refs where given attribute has a given value\n   * @param {String} attr\n   * @param {String} value\n   * @returns {Array<Object>}\n   */\n  get( attr, value ) {\n\n    attr = attr.toLowerCase()\n    value = value.toLowerCase()\n\n    var links = []\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      if( typeof this.refs[ i ][ attr ] === 'string' && this.refs[ i ][ attr ].toLowerCase() === value ) {\n        links.push( this.refs[ i ] )\n      }\n    }\n\n    return links\n\n  }\n\n  /** Sets a reference. */\n  set( link ) {\n    this.refs.push( link )\n    return this\n  }\n\n  /**\n   * Sets a reference if a reference with similar properties isnâ€™t already set.\n   */\n  setUnique( link ) {\n\n    if( !this.refs.some(( ref ) => shallowCompareObjects( ref, link )) ) {\n      this.refs.push( link )\n    }\n\n    return this\n\n  }\n\n  has( attr, value ) {\n\n    attr = attr.toLowerCase()\n    value = value.toLowerCase()\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      if( typeof this.refs[ i ][ attr ] === 'string' && this.refs[ i ][ attr ].toLowerCase() === value ) {\n        return true\n      }\n    }\n\n    return false\n\n  }\n\n  parse( value, offset ) {\n\n    offset = offset || 0\n    value = offset ? value.slice( offset ) : value\n\n    // Trim & unfold folded lines\n    value = trim( value ).replace( WS_FOLD_PATTERN, '' )\n\n    var state = STATE.IDLE\n    var length = value.length\n    var offset = 0\n    var ref = null\n\n    while( offset < length ) {\n      if( state === STATE.IDLE ) {\n        if( hasWhitespace( value[offset] ) ) {\n          offset++\n          continue\n        } else if( value[offset] === '<' ) {\n          if( ref != null ) {\n            ref.rel != null ?\n              this.refs.push( ...Link.expandRelations( ref ) ) :\n              this.refs.push( ref )\n          }\n          var end = value.indexOf( '>', offset )\n          if( end === -1 ) throw new Error( 'Expected end of URI delimiter at offset ' + offset )\n          ref = { uri: value.slice( offset + 1, end ) }\n          // this.refs.push( ref )\n          offset = end\n          state = STATE.URI\n        } else {\n          throw new Error( 'Unexpected character \"' + value[offset] + '\" at offset ' + offset )\n        }\n        offset++\n      } else if( state === STATE.URI ) {\n        if( hasWhitespace( value[offset] ) ) {\n          offset++\n          continue\n        } else if( value[offset] === ';' ) {\n          state = STATE.ATTR\n          offset++\n        } else if( value[offset] === ',' ) {\n          state = STATE.IDLE\n          offset++\n        } else {\n          throw new Error( 'Unexpected character \"' + value[offset] + '\" at offset ' + offset )\n        }\n      } else if( state === STATE.ATTR ) {\n        if( value[offset] ===';' || hasWhitespace( value[offset] ) ) {\n          offset++\n          continue\n        }\n        var end = value.indexOf( '=', offset )\n        if( end === -1 ) end = value.indexOf( ';', offset )\n        if( end === -1 ) end = value.length\n        var attr = trim( value.slice( offset, end ) ).toLowerCase()\n        var attrValue = ''\n        offset = end + 1\n        offset = skipWhitespace( value, offset )\n        if( value[offset] === '\"' ) {\n          offset++\n          while( offset < length ) {\n            if( value[offset] === '\"' ) {\n              offset++; break\n            }\n            if( value[offset] === '\\\\' ) {\n              offset++\n            }\n            attrValue += value[offset]\n            offset++\n          }\n        } else {\n          var end = offset + 1\n          while( !DELIMITER_PATTERN.test( value[end] ) && end < length ) {\n            end++\n          }\n          attrValue = value.slice( offset, end )\n          offset = end\n        }\n        if( ref[ attr ] && Link.isSingleOccurenceAttr( attr ) ) {\n          // Ignore multiples of attributes which may only appear once\n        } else if( attr[ attr.length - 1 ] === '*' ) {\n          ref[ attr ] = Link.parseExtendedValue( attrValue )\n        } else {\n          attrValue = attr === 'type' ?\n            attrValue.toLowerCase() : attrValue\n          if( ref[ attr ] != null ) {\n            if( Array.isArray( ref[ attr ] ) ) {\n              ref[ attr ].push( attrValue )\n            } else {\n              ref[ attr ] = [ ref[ attr ], attrValue ]\n            }\n          } else {\n            ref[ attr ] = attrValue\n          }\n        }\n        switch( value[offset] ) {\n          case ',': state = STATE.IDLE; break\n          case ';': state = STATE.ATTR; break\n        }\n        offset++\n      } else {\n        throw new Error( 'Unknown parser state \"' + state + '\"' )\n      }\n    }\n\n    if( ref != null ) {\n      ref.rel != null ?\n        this.refs.push( ...Link.expandRelations( ref ) ) :\n        this.refs.push( ref )\n    }\n\n    ref = null\n\n    return this\n\n  }\n\n  toString() {\n\n    var refs = []\n    var link = ''\n    var ref = null\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      ref = this.refs[i]\n      link = Object.keys( this.refs[i] ).reduce( function( link, attr ) {\n        if( attr === 'uri' ) return link\n        return link + '; ' + Link.formatAttribute( attr, ref[ attr ] )\n      }, '<' + ref.uri + '>' )\n      refs.push( link )\n    }\n\n    return refs.join( ', ' )\n\n  }\n\n}\n\n/**\n * Determines whether an encoding can be\n * natively handled with a `Buffer`\n * @param {String} value\n * @returns {Boolean}\n */\nLink.isCompatibleEncoding = function( value ) {\n  return COMPATIBLE_ENCODING_PATTERN.test( value )\n}\n\nLink.parse = function( value, offset ) {\n  return new Link().parse( value, offset )\n}\n\nLink.isSingleOccurenceAttr = function( attr ) {\n  return attr === 'rel' || attr === 'type' || attr === 'media' ||\n    attr === 'title' || attr === 'title*'\n}\n\nLink.isTokenAttr = function( attr ) {\n  return attr === 'rel' || attr === 'type' || attr === 'anchor'\n}\n\nLink.escapeQuotes = function( value ) {\n  return value.replace( /\"/g, '\\\\\"' )\n}\n\nLink.expandRelations = function( ref ) {\n  var rels = ref.rel.split( ' ' )\n  return rels.map( function( rel ) {\n    var value = Object.assign( {}, ref )\n    value.rel = rel\n    return value\n  })\n}\n\n/**\n * Parses an extended value and attempts to decode it\n * @internal\n * @param {String} value\n * @return {Object}\n */\nLink.parseExtendedValue = function( value ) {\n  var parts = /([^']+)?(?:'([^']*)')?(.+)/.exec( value )\n  return {\n    language: parts[2].toLowerCase(),\n    encoding: Link.isCompatibleEncoding( parts[1] ) ?\n      null : parts[1].toLowerCase(),\n    value: Link.isCompatibleEncoding( parts[1] ) ?\n      decodeURIComponent( parts[3] ) : parts[3]\n  }\n}\n\n/**\n * Format a given extended attribute and it's value\n * @param {String} attr\n * @param {Object} data\n * @return {String}\n */\nLink.formatExtendedAttribute = function( attr, data ) {\n\n  var encoding = ( data.encoding || 'utf-8' ).toUpperCase()\n  var language = data.language || 'en'\n\n  var encodedValue = ''\n\n  if( Buffer.isBuffer( data.value ) && Link.isCompatibleEncoding( encoding ) ) {\n    encodedValue = data.value.toString( encoding )\n  } else if( Buffer.isBuffer( data.value ) ) {\n    encodedValue = data.value.toString( 'hex' )\n      .replace( /[0-9a-f]{2}/gi, '%$1' )\n  } else {\n    encodedValue = encodeURIComponent( data.value )\n  }\n\n  return attr + '=' + encoding + '\\'' +\n    language + '\\'' + encodedValue\n\n}\n\n/**\n * Format a given attribute and it's value\n * @param {String} attr\n * @param {String|Object} value\n * @return {String}\n */\nLink.formatAttribute = function( attr, value ) {\n\n  if( Array.isArray( value ) ) {\n    return value.map(( item ) => {\n      return Link.formatAttribute( attr, item )\n    }).join( '; ' )\n  }\n\n  if( attr[ attr.length - 1 ] === '*' || typeof value !== 'string' ) {\n    return Link.formatExtendedAttribute( attr, value )\n  }\n\n  if( Link.isTokenAttr( attr ) ) {\n    value = needsQuotes( value ) ?\n      '\"' + Link.escapeQuotes( value ) + '\"' :\n      Link.escapeQuotes( value )\n  } else if( needsQuotes( value ) ) {\n    value = encodeURIComponent( value )\n    // We don't need to escape <SP> <,> <;> within quotes\n    value = value\n      .replace( /%20/g, ' ' )\n      .replace( /%2C/g, ',' )\n      .replace( /%3B/g, ';' )\n\n    value = '\"' + value + '\"'\n  }\n\n  return attr + '=' + value\n\n}\n\nmodule.exports = Link\n","import type {\n  AxiosError,\n  AxiosResponse,\n  Method,\n  RawAxiosRequestHeaders,\n} from 'axios';\nimport axios from 'axios';\nimport LinkHeader from 'http-link-header';\n\nimport { getAccessToken } from './initial_state';\nimport ready from './ready';\n\nexport const getLinks = (response: AxiosResponse) => {\n  const value = response.headers.link as string | undefined;\n\n  if (!value) {\n    return new LinkHeader();\n  }\n\n  return LinkHeader.parse(value);\n};\n\nconst csrfHeader: RawAxiosRequestHeaders = {};\n\nconst setCSRFHeader = () => {\n  const csrfToken = document.querySelector<HTMLMetaElement>(\n    'meta[name=csrf-token]',\n  );\n\n  if (csrfToken) {\n    csrfHeader['X-CSRF-Token'] = csrfToken.content;\n  }\n};\n\nvoid ready(setCSRFHeader);\n\nconst authorizationTokenFromInitialState = (): RawAxiosRequestHeaders => {\n  const accessToken = getAccessToken();\n\n  if (!accessToken) return {};\n\n  return {\n    Authorization: `Bearer ${accessToken}`,\n  };\n};\n\n// eslint-disable-next-line import/no-default-export\nexport default function api(withAuthorization = true) {\n  const instance = axios.create({\n    transitional: {\n      clarifyTimeoutError: true,\n    },\n    headers: {\n      ...csrfHeader,\n      ...(withAuthorization ? authorizationTokenFromInitialState() : {}),\n    },\n\n    transformResponse: [\n      function (data: unknown) {\n        try {\n          return JSON.parse(data as string) as unknown;\n        } catch {\n          return data;\n        }\n      },\n    ],\n  });\n\n  instance.interceptors.response.use(\n    (response: AxiosResponse) => {\n      if (response.headers.deprecation) {\n        console.warn(\n          `Deprecated request: ${response.config.method} ${response.config.url}`,\n        );\n      }\n      return response;\n    },\n    (error: AxiosError) => {\n      return Promise.reject(error);\n    },\n  );\n\n  return instance;\n}\n\ntype ApiUrl = `v${1 | 2}/${string}`;\ntype RequestParamsOrData = Record<string, unknown>;\n\nexport async function apiRequest<ApiResponse = unknown>(\n  method: Method,\n  url: string,\n  args: {\n    signal?: AbortSignal;\n    params?: RequestParamsOrData;\n    data?: RequestParamsOrData;\n    timeout?: number;\n  } = {},\n) {\n  const { data } = await api().request<ApiResponse>({\n    method,\n    url: '/api/' + url,\n    ...args,\n  });\n\n  return data;\n}\n\nexport async function apiRequestGet<ApiResponse = unknown>(\n  url: ApiUrl,\n  params?: RequestParamsOrData,\n) {\n  return apiRequest<ApiResponse>('GET', url, { params });\n}\n\nexport async function apiRequestPost<ApiResponse = unknown>(\n  url: ApiUrl,\n  data?: RequestParamsOrData,\n) {\n  return apiRequest<ApiResponse>('POST', url, { data });\n}\n\nexport async function apiRequestPut<ApiResponse = unknown>(\n  url: ApiUrl,\n  data?: RequestParamsOrData,\n) {\n  return apiRequest<ApiResponse>('PUT', url, { data });\n}\n\nexport async function apiRequestDelete<ApiResponse = unknown>(\n  url: ApiUrl,\n  params?: RequestParamsOrData,\n) {\n  return apiRequest<ApiResponse>('DELETE', url, { params });\n}\n"],"names":["COMPATIBLE_ENCODING_PATTERN","WS_TRIM_PATTERN","WS_CHAR_PATTERN","WS_FOLD_PATTERN","DELIMITER_PATTERN","WS_DELIMITER_PATTERN","TOKEN_PATTERN","STATE","trim","value","hasWhitespace","skipWhitespace","offset","needsQuotes","shallowCompareObjects","object1","object2","key","Link","links","type","i","attr","link","ref","state","length","end","attrValue","refs","rels","rel","parts","data","encoding","language","encodedValue","item","getLinks","response","headers","LinkHeader","parse","csrfHeader","setCSRFHeader","csrfToken","document","querySelector","content","ready","authorizationTokenFromInitialState","accessToken","getAccessToken","Authorization","api","withAuthorization","instance","axios","create","transitional","clarifyTimeoutError","transformResponse","JSON","interceptors","use","deprecation","console","warn","config","method","url","error","Promise","reject","apiRequest","args","request","apiRequestGet","params","apiRequestPost","apiRequestPut","apiRequestDelete"],"mappings":"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","x_google_ignoreList":[0]}