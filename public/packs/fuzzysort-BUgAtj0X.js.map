{"version":3,"file":"fuzzysort-BUgAtj0X.js","sources":["../../node_modules/fuzzysort/fuzzysort.js"],"sourcesContent":["// https://github.com/farzher/fuzzysort v3.0.2\r\n\r\n// UMD (Universal Module Definition) for fuzzysort\r\n;((root, UMD) => {\r\n  if(typeof define === 'function' && define.amd) define([], UMD)\r\n  else if(typeof module === 'object' && module.exports) module.exports = UMD()\r\n  else root['fuzzysort'] = UMD()\r\n})(this, _ => {\r\n  'use strict'\r\n\r\n  var single = (search, target) => {\r\n    if(!search || !target) return NULL\r\n\r\n    var preparedSearch = getPreparedSearch(search)\r\n    if(!isPrepared(target)) target = getPrepared(target)\r\n\r\n    var searchBitflags = preparedSearch.bitflags\r\n    if((searchBitflags & target._bitflags) !== searchBitflags) return NULL\r\n\r\n    return algorithm(preparedSearch, target)\r\n  }\r\n\r\n  var go = (search, targets, options) => {\r\n    if(!search) return options?.all ? all(targets, options) : noResults\r\n\r\n    var preparedSearch = getPreparedSearch(search)\r\n    var searchBitflags = preparedSearch.bitflags\r\n    var containsSpace  = preparedSearch.containsSpace\r\n\r\n    var threshold = denormalizeScore( options?.threshold || 0 )\r\n    var limit     = options?.limit || INFINITY\r\n\r\n    var resultsLen = 0; var limitedCount = 0\r\n    var targetsLen = targets.length\r\n\r\n    function push_result(result) {\r\n      if(resultsLen < limit) { q.add(result); ++resultsLen }\r\n      else {\r\n        ++limitedCount\r\n        if(result._score > q.peek()._score) q.replaceTop(result)\r\n      }\r\n    }\r\n\r\n    // This code is copy/pasted 3 times for performance reasons [options.key, options.keys, no keys]\r\n\r\n    // options.key\r\n    if(options?.key) {\r\n      var key = options.key\r\n      for(var i = 0; i < targetsLen; ++i) { var obj = targets[i]\r\n        var target = getValue(obj, key)\r\n        if(!target) continue\r\n        if(!isPrepared(target)) target = getPrepared(target)\r\n\r\n        if((searchBitflags & target._bitflags) !== searchBitflags) continue\r\n        var result = algorithm(preparedSearch, target)\r\n        if(result === NULL) continue\r\n        if(result._score < threshold) continue\r\n\r\n        result.obj = obj\r\n        push_result(result)\r\n      }\r\n\r\n    // options.keys\r\n    } else if(options?.keys) {\r\n      var keys = options.keys\r\n      var keysLen = keys.length\r\n\r\n      outer: for(var i = 0; i < targetsLen; ++i) { var obj = targets[i]\r\n\r\n        { // early out based on bitflags\r\n          var keysBitflags = 0\r\n          for (var keyI = 0; keyI < keysLen; ++keyI) {\r\n            var key = keys[keyI]\r\n            var target = getValue(obj, key)\r\n            if(!target) { tmpTargets[keyI] = noTarget; continue }\r\n            if(!isPrepared(target)) target = getPrepared(target)\r\n            tmpTargets[keyI] = target\r\n\r\n            keysBitflags |= target._bitflags\r\n          }\r\n\r\n          if((searchBitflags & keysBitflags) !== searchBitflags) continue\r\n        }\r\n\r\n        if(containsSpace) for(let i=0; i<preparedSearch.spaceSearches.length; i++) keysSpacesBestScores[i] = NEGATIVE_INFINITY\r\n\r\n        for (var keyI = 0; keyI < keysLen; ++keyI) {\r\n          target = tmpTargets[keyI]\r\n          if(target === noTarget) { tmpResults[keyI] = noTarget; continue }\r\n\r\n          tmpResults[keyI] = algorithm(preparedSearch, target, /*allowSpaces=*/false, /*allowPartialMatch=*/containsSpace)\r\n          if(tmpResults[keyI] === NULL) { tmpResults[keyI] = noTarget; continue }\r\n\r\n          // todo: this seems weird and wrong. like what if our first match wasn't good. this should just replace it instead of averaging with it\r\n          // if our second match isn't good we ignore it instead of averaging with it\r\n          if(containsSpace) for(let i=0; i<preparedSearch.spaceSearches.length; i++) {\r\n            if(allowPartialMatchScores[i] > -1000) {\r\n              if(keysSpacesBestScores[i] > NEGATIVE_INFINITY) {\r\n                var tmp = (keysSpacesBestScores[i] + allowPartialMatchScores[i]) / 4/*bonus score for having multiple matches*/\r\n                if(tmp > keysSpacesBestScores[i]) keysSpacesBestScores[i] = tmp\r\n              }\r\n            }\r\n            if(allowPartialMatchScores[i] > keysSpacesBestScores[i]) keysSpacesBestScores[i] = allowPartialMatchScores[i]\r\n          }\r\n        }\r\n\r\n        if(containsSpace) {\r\n          for(let i=0; i<preparedSearch.spaceSearches.length; i++) { if(keysSpacesBestScores[i] === NEGATIVE_INFINITY) continue outer }\r\n        } else {\r\n          var hasAtLeast1Match = false\r\n          for(let i=0; i < keysLen; i++) { if(tmpResults[i]._score !== NEGATIVE_INFINITY) { hasAtLeast1Match = true; break } }\r\n          if(!hasAtLeast1Match) continue\r\n        }\r\n\r\n        var objResults = new KeysResult(keysLen)\r\n        for(let i=0; i < keysLen; i++) { objResults[i] = tmpResults[i] }\r\n\r\n        if(containsSpace) {\r\n          var score = 0\r\n          for(let i=0; i<preparedSearch.spaceSearches.length; i++) score += keysSpacesBestScores[i]\r\n        } else {\r\n          // todo could rewrite this scoring to be more similar to when there's spaces\r\n          // if we match multiple keys give us bonus points\r\n          var score = NEGATIVE_INFINITY\r\n          for(let i=0; i<keysLen; i++) {\r\n            var result = objResults[i]\r\n            if(result._score > -1000) {\r\n              if(score > NEGATIVE_INFINITY) {\r\n                var tmp = (score + result._score) / 4/*bonus score for having multiple matches*/\r\n                if(tmp > score) score = tmp\r\n              }\r\n            }\r\n            if(result._score > score) score = result._score\r\n          }\r\n        }\r\n\r\n        objResults.obj = obj\r\n        objResults._score = score\r\n        if(options?.scoreFn) {\r\n          score = options.scoreFn(objResults)\r\n          if(!score) continue\r\n          score = denormalizeScore(score)\r\n          objResults._score = score\r\n        }\r\n\r\n        if(score < threshold) continue\r\n        push_result(objResults)\r\n      }\r\n\r\n    // no keys\r\n    } else {\r\n      for(var i = 0; i < targetsLen; ++i) { var target = targets[i]\r\n        if(!target) continue\r\n        if(!isPrepared(target)) target = getPrepared(target)\r\n\r\n        if((searchBitflags & target._bitflags) !== searchBitflags) continue\r\n        var result = algorithm(preparedSearch, target)\r\n        if(result === NULL) continue\r\n        if(result._score < threshold) continue\r\n\r\n        push_result(result)\r\n      }\r\n    }\r\n\r\n    if(resultsLen === 0) return noResults\r\n    var results = new Array(resultsLen)\r\n    for(var i = resultsLen - 1; i >= 0; --i) results[i] = q.poll()\r\n    results.total = resultsLen + limitedCount\r\n    return results\r\n  }\r\n\r\n\r\n  // this is written as 1 function instead of 2 for minification. perf seems fine ...\r\n  // except when minified. the perf is very slow\r\n  var highlight = (result, open='<b>', close='</b>') => {\r\n    var callback = typeof open === 'function' ? open : undefined\r\n\r\n    var target      = result.target\r\n    var targetLen   = target.length\r\n    var indexes     = result.indexes\r\n    var highlighted = ''\r\n    var matchI      = 0\r\n    var indexesI    = 0\r\n    var opened      = false\r\n    var parts       = []\r\n\r\n    for(var i = 0; i < targetLen; ++i) { var char = target[i]\r\n      if(indexes[indexesI] === i) {\r\n        ++indexesI\r\n        if(!opened) { opened = true\r\n          if(callback) {\r\n            parts.push(highlighted); highlighted = ''\r\n          } else {\r\n            highlighted += open\r\n          }\r\n        }\r\n\r\n        if(indexesI === indexes.length) {\r\n          if(callback) {\r\n            highlighted += char\r\n            parts.push(callback(highlighted, matchI++)); highlighted = ''\r\n            parts.push(target.substr(i+1))\r\n          } else {\r\n            highlighted += char + close + target.substr(i+1)\r\n          }\r\n          break\r\n        }\r\n      } else {\r\n        if(opened) { opened = false\r\n          if(callback) {\r\n            parts.push(callback(highlighted, matchI++)); highlighted = ''\r\n          } else {\r\n            highlighted += close\r\n          }\r\n        }\r\n      }\r\n      highlighted += char\r\n    }\r\n\r\n    return callback ? parts : highlighted\r\n  }\r\n\r\n\r\n  var prepare = (target) => {\r\n    if(typeof target === 'number') target = ''+target\r\n    else if(typeof target !== 'string') target = ''\r\n    var info = prepareLowerInfo(target)\r\n    return new_result(target, {_targetLower:info._lower, _targetLowerCodes:info.lowerCodes, _bitflags:info.bitflags})\r\n  }\r\n\r\n  var cleanup = () => { preparedCache.clear(); preparedSearchCache.clear() }\r\n\r\n\r\n  // Below this point is only internal code\r\n  // Below this point is only internal code\r\n  // Below this point is only internal code\r\n  // Below this point is only internal code\r\n\r\n\r\n  class Result {\r\n    get ['indexes']() { return this._indexes.slice(0, this._indexes.len).sort((a,b)=>a-b) }\r\n    set ['indexes'](indexes) { return this._indexes = indexes }\r\n    ['highlight'](open, close) { return highlight(this, open, close) }\r\n    get ['score']() { return normalizeScore(this._score) }\r\n    set ['score'](score) { this._score = denormalizeScore(score) }\r\n  }\r\n\r\n  class KeysResult extends Array {\r\n    get ['score']() { return normalizeScore(this._score) }\r\n    set ['score'](score) { this._score = denormalizeScore(score) }\r\n  }\r\n\r\n  var new_result = (target, options) => {\r\n    const result = new Result()\r\n    result['target']             = target\r\n    result['obj']                = options.obj                   ?? NULL\r\n    result._score                = options._score                ?? NEGATIVE_INFINITY\r\n    result._indexes              = options._indexes              ?? []\r\n    result._targetLower          = options._targetLower          ?? ''\r\n    result._targetLowerCodes     = options._targetLowerCodes     ?? NULL\r\n    result._nextBeginningIndexes = options._nextBeginningIndexes ?? NULL\r\n    result._bitflags             = options._bitflags             ?? 0\r\n    return result\r\n  }\r\n\r\n\r\n  var normalizeScore = score => {\r\n    if(score === NEGATIVE_INFINITY) return 0\r\n    if(score > 1) return score\r\n    return Math.E ** ( ((-score + 1)**.04307 - 1) * -2)\r\n  }\r\n  var denormalizeScore = normalizedScore => {\r\n    if(normalizedScore === 0) return NEGATIVE_INFINITY\r\n    if(normalizedScore > 1) return normalizedScore\r\n    return 1 - Math.pow((Math.log(normalizedScore) / -2 + 1), 1 / 0.04307)\r\n  }\r\n\r\n\r\n  var prepareSearch = (search) => {\r\n    if(typeof search === 'number') search = ''+search\r\n    else if(typeof search !== 'string') search = ''\r\n    search = search.trim()\r\n    var info = prepareLowerInfo(search)\r\n\r\n    var spaceSearches = []\r\n    if(info.containsSpace) {\r\n      var searches = search.split(/\\s+/)\r\n      searches = [...new Set(searches)] // distinct\r\n      for(var i=0; i<searches.length; i++) {\r\n        if(searches[i] === '') continue\r\n        var _info = prepareLowerInfo(searches[i])\r\n        spaceSearches.push({lowerCodes:_info.lowerCodes, _lower:searches[i].toLowerCase(), containsSpace:false})\r\n      }\r\n    }\r\n\r\n    return {lowerCodes: info.lowerCodes, _lower: info._lower, containsSpace: info.containsSpace, bitflags: info.bitflags, spaceSearches: spaceSearches}\r\n  }\r\n\r\n\r\n\r\n  var getPrepared = (target) => {\r\n    if(target.length > 999) return prepare(target) // don't cache huge targets\r\n    var targetPrepared = preparedCache.get(target)\r\n    if(targetPrepared !== undefined) return targetPrepared\r\n    targetPrepared = prepare(target)\r\n    preparedCache.set(target, targetPrepared)\r\n    return targetPrepared\r\n  }\r\n  var getPreparedSearch = (search) => {\r\n    if(search.length > 999) return prepareSearch(search) // don't cache huge searches\r\n    var searchPrepared = preparedSearchCache.get(search)\r\n    if(searchPrepared !== undefined) return searchPrepared\r\n    searchPrepared = prepareSearch(search)\r\n    preparedSearchCache.set(search, searchPrepared)\r\n    return searchPrepared\r\n  }\r\n\r\n\r\n  var all = (targets, options) => {\r\n    var results = []; results.total = targets.length // this total can be wrong if some targets are skipped\r\n\r\n    var limit = options?.limit || INFINITY\r\n\r\n    if(options?.key) {\r\n      for(var i=0;i<targets.length;i++) { var obj = targets[i]\r\n        var target = getValue(obj, options.key)\r\n        if(target == NULL) continue\r\n        if(!isPrepared(target)) target = getPrepared(target)\r\n        var result = new_result(target.target, {_score: target._score, obj: obj})\r\n        results.push(result); if(results.length >= limit) return results\r\n      }\r\n    } else if(options?.keys) {\r\n      for(var i=0;i<targets.length;i++) { var obj = targets[i]\r\n        var objResults = new KeysResult(options.keys.length)\r\n        for (var keyI = options.keys.length - 1; keyI >= 0; --keyI) {\r\n          var target = getValue(obj, options.keys[keyI])\r\n          if(!target) { objResults[keyI] = noTarget; continue }\r\n          if(!isPrepared(target)) target = getPrepared(target)\r\n          target._score = NEGATIVE_INFINITY\r\n          target._indexes.len = 0\r\n          objResults[keyI] = target\r\n        }\r\n        objResults.obj = obj\r\n        objResults._score = NEGATIVE_INFINITY\r\n        results.push(objResults); if(results.length >= limit) return results\r\n      }\r\n    } else {\r\n      for(var i=0;i<targets.length;i++) { var target = targets[i]\r\n        if(target == NULL) continue\r\n        if(!isPrepared(target)) target = getPrepared(target)\r\n        target._score = NEGATIVE_INFINITY\r\n        target._indexes.len = 0\r\n        results.push(target); if(results.length >= limit) return results\r\n      }\r\n    }\r\n\r\n    return results\r\n  }\r\n\r\n\r\n  var algorithm = (preparedSearch, prepared, allowSpaces=false, allowPartialMatch=false) => {\r\n    if(allowSpaces===false && preparedSearch.containsSpace) return algorithmSpaces(preparedSearch, prepared, allowPartialMatch)\r\n\r\n    var searchLower      = preparedSearch._lower\r\n    var searchLowerCodes = preparedSearch.lowerCodes\r\n    var searchLowerCode  = searchLowerCodes[0]\r\n    var targetLowerCodes = prepared._targetLowerCodes\r\n    var searchLen        = searchLowerCodes.length\r\n    var targetLen        = targetLowerCodes.length\r\n    var searchI          = 0 // where we at\r\n    var targetI          = 0 // where you at\r\n    var matchesSimpleLen = 0\r\n\r\n    // very basic fuzzy match; to remove non-matching targets ASAP!\r\n    // walk through target. find sequential matches.\r\n    // if all chars aren't found then exit\r\n    for(;;) {\r\n      var isMatch = searchLowerCode === targetLowerCodes[targetI]\r\n      if(isMatch) {\r\n        matchesSimple[matchesSimpleLen++] = targetI\r\n        ++searchI; if(searchI === searchLen) break\r\n        searchLowerCode = searchLowerCodes[searchI]\r\n      }\r\n      ++targetI; if(targetI >= targetLen) return NULL // Failed to find searchI\r\n    }\r\n\r\n    var searchI = 0\r\n    var successStrict = false\r\n    var matchesStrictLen = 0\r\n\r\n    var nextBeginningIndexes = prepared._nextBeginningIndexes\r\n    if(nextBeginningIndexes === NULL) nextBeginningIndexes = prepared._nextBeginningIndexes = prepareNextBeginningIndexes(prepared.target)\r\n    targetI = matchesSimple[0]===0 ? 0 : nextBeginningIndexes[matchesSimple[0]-1]\r\n\r\n    // Our target string successfully matched all characters in sequence!\r\n    // Let's try a more advanced and strict test to improve the score\r\n    // only count it as a match if it's consecutive or a beginning character!\r\n    var backtrackCount = 0\r\n    if(targetI !== targetLen) for(;;) {\r\n      if(targetI >= targetLen) {\r\n        // We failed to find a good spot for this search char, go back to the previous search char and force it forward\r\n        if(searchI <= 0) break // We failed to push chars forward for a better match\r\n\r\n        ++backtrackCount; if(backtrackCount > 200) break // exponential backtracking is taking too long, just give up and return a bad match\r\n\r\n        --searchI\r\n        var lastMatch = matchesStrict[--matchesStrictLen]\r\n        targetI = nextBeginningIndexes[lastMatch]\r\n\r\n      } else {\r\n        var isMatch = searchLowerCodes[searchI] === targetLowerCodes[targetI]\r\n        if(isMatch) {\r\n          matchesStrict[matchesStrictLen++] = targetI\r\n          ++searchI; if(searchI === searchLen) { successStrict = true; break }\r\n          ++targetI\r\n        } else {\r\n          targetI = nextBeginningIndexes[targetI]\r\n        }\r\n      }\r\n    }\r\n\r\n    // check if it's a substring match\r\n    var substringIndex = searchLen <= 1 ? -1 : prepared._targetLower.indexOf(searchLower, matchesSimple[0]) // perf: this is slow\r\n    var isSubstring = !!~substringIndex\r\n    var isSubstringBeginning = !isSubstring ? false : substringIndex===0 || prepared._nextBeginningIndexes[substringIndex-1] === substringIndex\r\n\r\n    // if it's a substring match but not at a beginning index, let's try to find a substring starting at a beginning index for a better score\r\n    if(isSubstring && !isSubstringBeginning) {\r\n      for(var i=0; i<nextBeginningIndexes.length; i=nextBeginningIndexes[i]) {\r\n        if(i <= substringIndex) continue\r\n\r\n        for(var s=0; s<searchLen; s++) if(searchLowerCodes[s] !== prepared._targetLowerCodes[i+s]) break\r\n        if(s === searchLen) { substringIndex = i; isSubstringBeginning = true; break }\r\n      }\r\n    }\r\n\r\n    // tally up the score & keep track of matches for highlighting later\r\n    // if it's a simple match, we'll switch to a substring match if a substring exists\r\n    // if it's a strict match, we'll switch to a substring match only if that's a better score\r\n\r\n    var calculateScore = matches => {\r\n      var score = 0\r\n\r\n      var extraMatchGroupCount = 0\r\n      for(var i = 1; i < searchLen; ++i) {\r\n        if(matches[i] - matches[i-1] !== 1) {score -= matches[i]; ++extraMatchGroupCount}\r\n      }\r\n      var unmatchedDistance = matches[searchLen-1] - matches[0] - (searchLen-1)\r\n\r\n      score -= (12+unmatchedDistance) * extraMatchGroupCount // penality for more groups\r\n\r\n      if(matches[0] !== 0) score -= matches[0]*matches[0]*.2 // penality for not starting near the beginning\r\n\r\n      if(!successStrict) {\r\n        score *= 1000\r\n      } else {\r\n        // successStrict on a target with too many beginning indexes loses points for being a bad target\r\n        var uniqueBeginningIndexes = 1\r\n        for(var i = nextBeginningIndexes[0]; i < targetLen; i=nextBeginningIndexes[i]) ++uniqueBeginningIndexes\r\n\r\n        if(uniqueBeginningIndexes > 24) score *= (uniqueBeginningIndexes-24)*10 // quite arbitrary numbers here ...\r\n      }\r\n\r\n      score -= (targetLen - searchLen)/2 // penality for longer targets\r\n\r\n      if(isSubstring)          score /= 1+searchLen*searchLen*1 // bonus for being a full substring\r\n      if(isSubstringBeginning) score /= 1+searchLen*searchLen*1 // bonus for substring starting on a beginningIndex\r\n\r\n      score -= (targetLen - searchLen)/2 // penality for longer targets\r\n\r\n      return score\r\n    }\r\n\r\n    if(!successStrict) {\r\n      if(isSubstring) for(var i=0; i<searchLen; ++i) matchesSimple[i] = substringIndex+i // at this point it's safe to overwrite matchehsSimple with substr matches\r\n      var matchesBest = matchesSimple\r\n      var score = calculateScore(matchesBest)\r\n    } else {\r\n      if(isSubstringBeginning) {\r\n        for(var i=0; i<searchLen; ++i) matchesSimple[i] = substringIndex+i // at this point it's safe to overwrite matchehsSimple with substr matches\r\n        var matchesBest = matchesSimple\r\n        var score = calculateScore(matchesSimple)\r\n      } else {\r\n        var matchesBest = matchesStrict\r\n        var score = calculateScore(matchesStrict)\r\n      }\r\n    }\r\n\r\n    prepared._score = score\r\n\r\n    for(var i = 0; i < searchLen; ++i) prepared._indexes[i] = matchesBest[i]\r\n    prepared._indexes.len = searchLen\r\n\r\n    const result    = new Result()\r\n    result.target   = prepared.target\r\n    result._score   = prepared._score\r\n    result._indexes = prepared._indexes\r\n    return result\r\n  }\r\n  var algorithmSpaces = (preparedSearch, target, allowPartialMatch) => {\r\n    var seen_indexes = new Set()\r\n    var score = 0\r\n    var result = NULL\r\n\r\n    var first_seen_index_last_search = 0\r\n    var searches = preparedSearch.spaceSearches\r\n    var searchesLen = searches.length\r\n    var changeslen = 0\r\n\r\n    // Return _nextBeginningIndexes back to its normal state\r\n    var resetNextBeginningIndexes = () => {\r\n      for(let i=changeslen-1; i>=0; i--) target._nextBeginningIndexes[nextBeginningIndexesChanges[i*2 + 0]] = nextBeginningIndexesChanges[i*2 + 1]\r\n    }\r\n\r\n    var hasAtLeast1Match = false\r\n    for(var i=0; i<searchesLen; ++i) {\r\n      allowPartialMatchScores[i] = NEGATIVE_INFINITY\r\n      var search = searches[i]\r\n\r\n      result = algorithm(search, target)\r\n      if(allowPartialMatch) {\r\n        if(result === NULL) continue\r\n        hasAtLeast1Match = true\r\n      } else {\r\n        if(result === NULL) {resetNextBeginningIndexes(); return NULL}\r\n      }\r\n\r\n      // if not the last search, we need to mutate _nextBeginningIndexes for the next search\r\n      var isTheLastSearch = i === searchesLen - 1\r\n      if(!isTheLastSearch) {\r\n        var indexes = result._indexes\r\n\r\n        var indexesIsConsecutiveSubstring = true\r\n        for(let i=0; i<indexes.len-1; i++) {\r\n          if(indexes[i+1] - indexes[i] !== 1) {\r\n            indexesIsConsecutiveSubstring = false; break;\r\n          }\r\n        }\r\n\r\n        if(indexesIsConsecutiveSubstring) {\r\n          var newBeginningIndex = indexes[indexes.len-1] + 1\r\n          var toReplace = target._nextBeginningIndexes[newBeginningIndex-1]\r\n          for(let i=newBeginningIndex-1; i>=0; i--) {\r\n            if(toReplace !== target._nextBeginningIndexes[i]) break\r\n            target._nextBeginningIndexes[i] = newBeginningIndex\r\n            nextBeginningIndexesChanges[changeslen*2 + 0] = i\r\n            nextBeginningIndexesChanges[changeslen*2 + 1] = toReplace\r\n            changeslen++\r\n          }\r\n        }\r\n      }\r\n\r\n      score += result._score / searchesLen\r\n      allowPartialMatchScores[i] = result._score / searchesLen\r\n\r\n      // dock points based on order otherwise \"c man\" returns Manifest.cpp instead of CheatManager.h\r\n      if(result._indexes[0] < first_seen_index_last_search) {\r\n        score -= (first_seen_index_last_search - result._indexes[0]) * 2\r\n      }\r\n      first_seen_index_last_search = result._indexes[0]\r\n\r\n      for(var j=0; j<result._indexes.len; ++j) seen_indexes.add(result._indexes[j])\r\n    }\r\n\r\n    if(allowPartialMatch && !hasAtLeast1Match) return NULL\r\n\r\n    resetNextBeginningIndexes()\r\n\r\n    // allows a search with spaces that's an exact substring to score well\r\n    var allowSpacesResult = algorithm(preparedSearch, target, /*allowSpaces=*/true)\r\n    if(allowSpacesResult !== NULL && allowSpacesResult._score > score) {\r\n      if(allowPartialMatch) {\r\n        for(var i=0; i<searchesLen; ++i) {\r\n          allowPartialMatchScores[i] = allowSpacesResult._score / searchesLen\r\n        }\r\n      }\r\n      return allowSpacesResult\r\n    }\r\n\r\n    if(allowPartialMatch) result = target\r\n    result._score = score\r\n\r\n    var i = 0\r\n    for (let index of seen_indexes) result._indexes[i++] = index\r\n    result._indexes.len = i\r\n\r\n    return result\r\n  }\r\n\r\n  // we use this instead of just .normalize('NFD').replace(/[\\u0300-\\u036f]/g, '') because that screws with japanese characters\r\n  var remove_accents = (str) => str.replace(/\\p{Script=Latin}+/gu, match => match.normalize('NFD')).replace(/[\\u0300-\\u036f]/g, '')\r\n\r\n  var prepareLowerInfo = (str) => {\r\n    str = remove_accents(str)\r\n    var strLen = str.length\r\n    var lower = str.toLowerCase()\r\n    var lowerCodes = [] // new Array(strLen)    sparse array is too slow\r\n    var bitflags = 0\r\n    var containsSpace = false // space isn't stored in bitflags because of how searching with a space works\r\n\r\n    for(var i = 0; i < strLen; ++i) {\r\n      var lowerCode = lowerCodes[i] = lower.charCodeAt(i)\r\n\r\n      if(lowerCode === 32) {\r\n        containsSpace = true\r\n        continue // it's important that we don't set any bitflags for space\r\n      }\r\n\r\n      var bit = lowerCode>=97&&lowerCode<=122 ? lowerCode-97 // alphabet\r\n              : lowerCode>=48&&lowerCode<=57  ? 26           // numbers\r\n                                                             // 3 bits available\r\n              : lowerCode<=127                ? 30           // other ascii\r\n              :                                 31           // other utf8\r\n      bitflags |= 1<<bit\r\n    }\r\n\r\n    return {lowerCodes:lowerCodes, bitflags:bitflags, containsSpace:containsSpace, _lower:lower}\r\n  }\r\n  var prepareBeginningIndexes = (target) => {\r\n    var targetLen = target.length\r\n    var beginningIndexes = []; var beginningIndexesLen = 0\r\n    var wasUpper = false\r\n    var wasAlphanum = false\r\n    for(var i = 0; i < targetLen; ++i) {\r\n      var targetCode = target.charCodeAt(i)\r\n      var isUpper = targetCode>=65&&targetCode<=90\r\n      var isAlphanum = isUpper || targetCode>=97&&targetCode<=122 || targetCode>=48&&targetCode<=57\r\n      var isBeginning = isUpper && !wasUpper || !wasAlphanum || !isAlphanum\r\n      wasUpper = isUpper\r\n      wasAlphanum = isAlphanum\r\n      if(isBeginning) beginningIndexes[beginningIndexesLen++] = i\r\n    }\r\n    return beginningIndexes\r\n  }\r\n  var prepareNextBeginningIndexes = (target) => {\r\n    target = remove_accents(target)\r\n    var targetLen = target.length\r\n    var beginningIndexes = prepareBeginningIndexes(target)\r\n    var nextBeginningIndexes = [] // new Array(targetLen)     sparse array is too slow\r\n    var lastIsBeginning = beginningIndexes[0]\r\n    var lastIsBeginningI = 0\r\n    for(var i = 0; i < targetLen; ++i) {\r\n      if(lastIsBeginning > i) {\r\n        nextBeginningIndexes[i] = lastIsBeginning\r\n      } else {\r\n        lastIsBeginning = beginningIndexes[++lastIsBeginningI]\r\n        nextBeginningIndexes[i] = lastIsBeginning===undefined ? targetLen : lastIsBeginning\r\n      }\r\n    }\r\n    return nextBeginningIndexes\r\n  }\r\n\r\n  var preparedCache       = new Map()\r\n  var preparedSearchCache = new Map()\r\n\r\n  // the theory behind these being globals is to reduce garbage collection by not making new arrays\r\n  var matchesSimple = []; var matchesStrict = []\r\n  var nextBeginningIndexesChanges = [] // allows straw berry to match strawberry well, by modifying the end of a substring to be considered a beginning index for the rest of the search\r\n  var keysSpacesBestScores = []; var allowPartialMatchScores = []\r\n  var tmpTargets = []; var tmpResults = []\r\n\r\n  // prop = 'key'                  2.5ms optimized for this case, seems to be about as fast as direct obj[prop]\r\n  // prop = 'key1.key2'            10ms\r\n  // prop = ['key1', 'key2']       27ms\r\n  // prop = obj => obj.tags.join() ??ms\r\n  var getValue = (obj, prop) => {\r\n    var tmp = obj[prop]; if(tmp !== undefined) return tmp\r\n    if(typeof prop === 'function') return prop(obj) // this should run first. but that makes string props slower\r\n    var segs = prop\r\n    if(!Array.isArray(prop)) segs = prop.split('.')\r\n    var len = segs.length\r\n    var i = -1\r\n    while (obj && (++i < len)) obj = obj[segs[i]]\r\n    return obj\r\n  }\r\n\r\n  var isPrepared = (x) => { return typeof x === 'object' && typeof x._bitflags === 'number' }\r\n  var INFINITY = Infinity; var NEGATIVE_INFINITY = -INFINITY\r\n  var noResults = []; noResults.total = 0\r\n  var NULL = null\r\n\r\n  var noTarget = prepare('')\r\n\r\n  // Hacked version of https://github.com/lemire/FastPriorityQueue.js\r\n  var fastpriorityqueue=r=>{var e=[],o=0,a={},v=r=>{for(var a=0,v=e[a],c=1;c<o;){var s=c+1;a=c,s<o&&e[s]._score<e[c]._score&&(a=s),e[a-1>>1]=e[a],c=1+(a<<1)}for(var f=a-1>>1;a>0&&v._score<e[f]._score;f=(a=f)-1>>1)e[a]=e[f];e[a]=v};return a.add=(r=>{var a=o;e[o++]=r;for(var v=a-1>>1;a>0&&r._score<e[v]._score;v=(a=v)-1>>1)e[a]=e[v];e[a]=r}),a.poll=(r=>{if(0!==o){var a=e[0];return e[0]=e[--o],v(),a}}),a.peek=(r=>{if(0!==o)return e[0]}),a.replaceTop=(r=>{e[0]=r,v()}),a}\r\n  var q = fastpriorityqueue() // reuse this\r\n\r\n  // fuzzysort is written this way for minification. all names are mangeled unless quoted\r\n  return {'single':single, 'go':go, 'prepare':prepare, 'cleanup':cleanup}\r\n}) // UMD\r\n"],"names":["root","UMD","module","this","_","single","search","target","NULL","preparedSearch","getPreparedSearch","isPrepared","getPrepared","searchBitflags","algorithm","go","targets","options","all","noResults","containsSpace","threshold","denormalizeScore","limit","INFINITY","resultsLen","limitedCount","targetsLen","push_result","result","q","key","i","obj","getValue","keys","keysLen","outer","keysBitflags","keyI","tmpTargets","noTarget","keysSpacesBestScores","NEGATIVE_INFINITY","tmpResults","allowPartialMatchScores","tmp","hasAtLeast1Match","objResults","KeysResult","score","results","highlight","open","close","callback","targetLen","indexes","highlighted","matchI","indexesI","opened","parts","char","prepare","info","prepareLowerInfo","new_result","cleanup","preparedCache","preparedSearchCache","Result","a","b","normalizeScore","normalizedScore","prepareSearch","spaceSearches","searches","_info","targetPrepared","searchPrepared","prepared","allowSpaces","allowPartialMatch","algorithmSpaces","searchLower","searchLowerCodes","searchLowerCode","targetLowerCodes","searchLen","searchI","targetI","matchesSimpleLen","isMatch","matchesSimple","successStrict","matchesStrictLen","nextBeginningIndexes","prepareNextBeginningIndexes","backtrackCount","lastMatch","matchesStrict","substringIndex","isSubstring","isSubstringBeginning","s","calculateScore","matches","extraMatchGroupCount","unmatchedDistance","uniqueBeginningIndexes","matchesBest","seen_indexes","first_seen_index_last_search","searchesLen","changeslen","resetNextBeginningIndexes","nextBeginningIndexesChanges","isTheLastSearch","indexesIsConsecutiveSubstring","newBeginningIndex","toReplace","j","allowSpacesResult","index","remove_accents","str","match","strLen","lower","lowerCodes","bitflags","lowerCode","bit","prepareBeginningIndexes","beginningIndexes","beginningIndexesLen","wasUpper","wasAlphanum","targetCode","isUpper","isAlphanum","isBeginning","lastIsBeginning","lastIsBeginningI","prop","segs","len","x","fastpriorityqueue","o","r","v","c","f"],"mappings":"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","x_google_ignoreList":[0]}